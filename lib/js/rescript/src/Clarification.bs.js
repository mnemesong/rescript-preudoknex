// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';


var applyOnlyTrue = (function (knex, colName) {
  return knex.where(colName, true);
});

var applyOnlyFalse = (function (knex, colName) {
  return knex.where(colName, false);
});

var applyOnlyNull = (function (knex, colName) {
  return knex.whereNull(colName);
});

var applyEq = (function (knex, colName, val) {
  return knex.where(colName, val);
});

var applyMore = (function (knex, colName, val) {
  return knex.where(colName, '>', val);
});

var applyLess = (function (knex, colName, val) {
  return knex.where(colName, '<', val);
});

var applyBetween = (function (knex, colName, v1, v2) {
  return knex.whereBetween(colName, [v1, v2]);
});

var applyIn = (function (knex, colName, vals) {
  return knex.whereIn(colName, vals);
});

var applyLike = (function (knex, colName, like) {
  return knex.whereLike(colName, like);
});

var applyILike = (function (knex, colName, like) {
  return knex.whereILike(colName, like);
});

var applyNot = (function (knex, colName, clar, convert) {
  knex = knex.clone();
  return knex.whereNot(builder => convert(builder, colName, clar));
});

var applyAnd = (function (knex, colName, clars, convert) {
  knex = knex.clone();
  clars.forEach(c => {
    knex = knex.andWhere(builder => convert(builder, colName, c));
  })
  return knex;
});

var applyOr = (function (knex, colName, clars, convert) {
  knex = knex.clone();
  clars.forEach(c => {
    knex = knex.orWhere(builder => convert(builder, colName, c));
  })
  return knex;
});

function applyStringClarification(knex, colName, clar) {
  if (typeof clar === "number") {
    if (clar === /* Any */0) {
      return knex;
    } else {
      return applyOnlyNull(knex, colName);
    }
  }
  switch (clar.TAG | 0) {
    case /* Not */0 :
        return applyNot(knex, colName, clar._0, applyStringClarification);
    case /* And */1 :
        return applyAnd(knex, colName, clar._0, applyStringClarification);
    case /* Or */2 :
        return applyOr(knex, colName, clar._0, applyStringClarification);
    case /* Eq */3 :
        return applyEq(knex, colName, clar._0);
    case /* More */4 :
        return applyMore(knex, colName, clar._0);
    case /* Less */5 :
        return applyLess(knex, colName, clar._0);
    case /* Between */6 :
        return applyBetween(knex, colName, clar._0, clar._1);
    case /* In */7 :
        return applyIn(knex, colName, clar._0);
    case /* Like */8 :
        return applyLike(knex, colName, clar._0);
    case /* ILike */9 :
        return applyILike(knex, colName, clar._0);
    
  }
}

function applyIntClarification(knex, colName, clar) {
  if (typeof clar === "number") {
    if (clar === /* Any */0) {
      return knex;
    } else {
      return applyOnlyNull(knex, colName);
    }
  }
  switch (clar.TAG | 0) {
    case /* Not */0 :
        return applyNot(knex, colName, clar._0, applyIntClarification);
    case /* And */1 :
        return applyAnd(knex, colName, clar._0, applyIntClarification);
    case /* Or */2 :
        return applyOr(knex, colName, clar._0, applyIntClarification);
    case /* Eq */3 :
        return applyEq(knex, colName, clar._0);
    case /* More */4 :
        return applyMore(knex, colName, clar._0);
    case /* Less */5 :
        return applyLess(knex, colName, clar._0);
    case /* In */6 :
        return applyIn(knex, colName, clar._0);
    case /* Between */7 :
        return applyBetween(knex, colName, clar._0, clar._1);
    
  }
}

function applyFloatClarification(knex, colName, clar) {
  if (typeof clar === "number") {
    if (clar === /* Any */0) {
      return knex;
    } else {
      return applyOnlyNull(knex, colName);
    }
  }
  switch (clar.TAG | 0) {
    case /* Not */0 :
        return applyNot(knex, colName, clar._0, applyFloatClarification);
    case /* And */1 :
        return applyAnd(knex, colName, clar._0, applyFloatClarification);
    case /* Or */2 :
        return applyOr(knex, colName, clar._0, applyFloatClarification);
    case /* More */3 :
        return applyMore(knex, colName, clar._0);
    case /* Less */4 :
        return applyLess(knex, colName, clar._0);
    case /* Between */5 :
        return applyBetween(knex, colName, clar._0, clar._1);
    
  }
}

function applyBoolClarification(knex, colName, clar) {
  if (typeof clar === "number") {
    switch (clar) {
      case /* Any */0 :
          return knex;
      case /* Null */1 :
          return applyOnlyNull(knex, colName);
      case /* OnlyTrue */2 :
          return applyOnlyTrue(knex, colName);
      case /* OnlyFalse */3 :
          return applyOnlyFalse(knex, colName);
      
    }
  } else {
    switch (clar.TAG | 0) {
      case /* Not */0 :
          return applyNot(knex, colName, clar._0, applyBoolClarification);
      case /* And */1 :
          return applyAnd(knex, colName, clar._0, applyBoolClarification);
      case /* Or */2 :
          return applyOr(knex, colName, clar._0, applyBoolClarification);
      
    }
  }
}

exports.applyOnlyTrue = applyOnlyTrue;
exports.applyOnlyFalse = applyOnlyFalse;
exports.applyOnlyNull = applyOnlyNull;
exports.applyEq = applyEq;
exports.applyMore = applyMore;
exports.applyLess = applyLess;
exports.applyBetween = applyBetween;
exports.applyIn = applyIn;
exports.applyLike = applyLike;
exports.applyILike = applyILike;
exports.applyNot = applyNot;
exports.applyAnd = applyAnd;
exports.applyOr = applyOr;
exports.applyStringClarification = applyStringClarification;
exports.applyIntClarification = applyIntClarification;
exports.applyFloatClarification = applyFloatClarification;
exports.applyBoolClarification = applyBoolClarification;
/* No side effect */
